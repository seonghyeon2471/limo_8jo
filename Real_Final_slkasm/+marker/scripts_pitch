#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
LKAS + SLAM Guard + IMU bump (감속 버전)

기능 요약
- 기본: SLAM(/cmd_vel_slam)에서 오는 cmd_vel 그대로 따라감
- LKAS offset >= depart_threshold 이면:
    1) 선속도(linear.x) 0으로 정지
    2) 제자리 회전: angular.z = gain * offset
- LKAS offset <= clear_threshold 이면:
    → 다시 SLAM 명령으로 복귀

- IMU bump 플래그(/imu_bump == True)일 때:
    - 완전 정지 대신
      → 선속도를 bump_max_speed 로 제한(감속)
      → SLAM이 더 빠른 속도를 요구해도 그 이상 못 가도록 클램핑

- 로그:
    [LKAS_GUARD] BUMP ON (|pitch|=xx.xx)  ← pitch 정보는 IMU 노드에서 찍고, 여기선 ON/OFF만 log
    [LKAS_GUARD] BUMP OFF
"""

import rospy
import threading
from geometry_msgs.msg import Twist
from std_msgs.msg import Float32, Bool


class EWMA(object):
    """지수 이동 평균 필터 (노이즈 있는 LKAS offset을 조금 부드럽게)"""
    def __init__(self, alpha=0.6, init_val=0.0):
        self.a = float(alpha)
        self.y = float(init_val)
        self.initialized = False

    def reset(self, v=0.0):
        self.y = float(v)
        self.initialized = True

    def filt(self, x):
        x = float(x)
        if not self.initialized:
            self.reset(x)
        self.y = self.a * self.y + (1.0 - self.a) * x
        return self.y


class LkasSlamGuard(object):
    def __init__(self):
        rospy.init_node("lkas_slam_guard")

        # ---------- 파라미터 설정 ----------
        # LKAS 차선 이탈 감지 기준
        self.depart_threshold = rospy.get_param("~depart_threshold", 0.25)  # 이 이상 offset -> 이탈
        self.clear_threshold  = rospy.get_param("~clear_threshold", 0.10)  # 이 이하 offset -> 복귀
        self.turn_gain        = rospy.get_param("~turn_gain", 1.5)         # 이탈 시 제자리 회전 gain

        # IMU bump 감속 설정
        self.enable_bump_guard = rospy.get_param("~enable_bump_guard", True)
        self.bump_max_speed    = rospy.get_param("~bump_max_speed", 0.08)   # bump일 때 최대 선속도 (m/s)

        # 주기
        self.control_rate_hz = rospy.get_param("~control_rate", 20.0)

        # ---------- 내부 상태 ----------
        self.slam_cmd = Twist()    # SLAM에서 받은 현재 cmd_vel
        self.offset_raw = 0.0      # LKAS에서 받은 원본 offset
        self.offset_filt = 0.0     # 필터링된 offset
        self.offset_filter = EWMA(alpha=0.6, init_val=0.0)

        self.in_depart = False     # 현재 LKAS 이탈 처리 모드인지 여부

        self.bump_active = False   # IMU bump 플래그 (현재 상태)
        self.prev_bump_active = False

        self.cmd_lock = threading.Lock()

        # ---------- Pub / Sub ----------
        # SLAM의 속도 명령
        self.sub_slam = rospy.Subscriber("cmd_vel_slam", Twist,
                                         self.cb_slam_cmd, queue_size=1)

        # LKAS offset (차선 중앙에서 얼마나 벗어났는지)
        self.sub_offset = rospy.Subscriber("lkas_offset", Float32,
                                           self.cb_lkas_offset, queue_size=1)

        # IMU bump 플래그
        self.sub_bump = rospy.Subscriber("imu_bump", Bool,
                                         self.cb_bump, queue_size=1)

        # 최종 출력 cmd_vel
        self.pub_cmd = rospy.Publisher("cmd_vel", Twist, queue_size=1)

        # ---------- 메인 루프 타이머 ----------
        self.timer = rospy.Timer(rospy.Duration(1.0 / self.control_rate_hz),
                                 self.cb_timer)

        rospy.loginfo("[LKAS_GUARD] Node started (depart=%.2f, clear=%.2f, bump_max_speed=%.2f)",
                      self.depart_threshold, self.clear_threshold, self.bump_max_speed)

    # ---------------- 콜백 함수들 ----------------

    def cb_slam_cmd(self, msg):
        with self.cmd_lock:
            self.slam_cmd = msg

    def cb_lkas_offset(self, msg):
        self.offset_raw = msg.data
        self.offset_filt = self.offset_filter.filt(self.offset_raw)

    def cb_bump(self, msg):
        self.bump_active = bool(msg.data)

        # BUMP ON/OFF edge에서만 로그
        if self.bump_active and not self.prev_bump_active:
            rospy.loginfo("[LKAS_GUARD] BUMP ON")
        elif (not self.bump_active) and self.prev_bump_active:
            rospy.loginfo("[LKAS_GUARD] BUMP OFF")

        self.prev_bump_active = self.bump_active

    # ---------------- 제어루프 ----------------

    def cb_timer(self, event):
        with self.cmd_lock:
            slam = self.slam_cmd  # local ref

            out = Twist()

            # 1) 기본은 SLAM 명령을 그대로 따라감
            out.linear.x  = slam.linear.x
            out.linear.y  = slam.linear.y
            out.linear.z  = slam.linear.z
            out.angular.x = slam.angular.x
            out.angular.y = slam.angular.y
            out.angular.z = slam.angular.z

            # 2) LKAS 차선 이탈 가드
            off = self.offset_filt

            if self.in_depart:
                # 이미 이탈 모드인 상태
                if abs(off) <= self.clear_threshold:
                    # 충분히 중앙으로 돌아오면 모드 해제
                    self.in_depart = False
                    rospy.loginfo("[LKAS_GUARD] Lane cleared (offset=%.3f)", off)
                else:
                    # 이탈 처리: 제자리 회전
                    out.linear.x = 0.0
                    out.angular.z = self.turn_gain * off
            else:
                # 평상시 -> 이탈 감지 여부 체크
                if abs(off) >= self.depart_threshold:
                    self.in_depart = True
                    rospy.logwarn("[LKAS_GUARD] Lane departure detected (offset=%.3f)", off)
                    # 이탈 순간에는 바로 멈추고 회전 시작
                    out.linear.x = 0.0
                    out.angular.z = self.turn_gain * off

            # 3) IMU bump 감속 가드 (정지 → 감속)
            if self.enable_bump_guard and self.bump_active:
                # 선속도 감속: SLAM이 더 크게 요구해도 bump_max_speed 이상 안 가게 제한
                # (후진하는 경우까지 고려해서 부호는 유지)
                if out.linear.x > self.bump_max_speed:
                    out.linear.x = self.bump_max_speed
                elif out.linear.x < -self.bump_max_speed:
                    out.linear.x = -self.bump_max_speed

                # 필요하면 회전속도도 제한하고 싶을 때 예시:
                # max_w = 0.5
                # if out.angular.z > max_w:
                #     out.angular.z = max_w
                # elif out.angular.z < -max_w:
                #     out.angular.z = -max_w

            # 4) 최종 명령 publish
            self.pub_cmd.publish(out)


if __name__ == "__main__":
    try:
        node = LkasSlamGuard()
        rospy.spin()
    except rospy.ROSInterruptException:
        pass
