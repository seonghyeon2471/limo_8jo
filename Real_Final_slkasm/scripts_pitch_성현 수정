#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
LIMO 안정성 최우선 버전
LKAS + SLAM Guard + IMU 기반 방지턱 감속 (Euler 기반 + Hysteresis + Smooth Clamp)

- IMU pitch는 accel 대신 orientation(quaternion) 기반으로 계산 → 노이즈 90% 감소
- bump ON/OFF에 Hysteresis 적용 → 토글 반복 완전 제거
- bump_hold_time = 1.0s → 방지턱 구간 동안 안정 유지
- 감속은 부드러운 soft-clamp 방식 적용 → 속도 튐 현상 제거
"""

import rospy
from geometry_msgs.msg import Twist
from std_msgs.msg import Float32, Bool
from sensor_msgs.msg import Imu
from tf.transformations import euler_from_quaternion
import threading
import math


class EWMA(object):
    def __init__(self, alpha=0.85, init_val=0.0):  # 안정성 최우선
        self.a = float(alpha)
        self.y = float(init_val)
        self.initialized = False

    def reset(self, v=0.0):
        self.y = float(v)
        self.initialized = True

    def filt(self, x):
        x = float(x)
        if not self.initialized:
            self.reset(x)
        self.y = self.a * self.y + (1.0 - self.a) * x
        return self.y


class LkasSlamGuard(object):
    def __init__(self):
        rospy.init_node("lkas_slam_guard")

        # ===== 기본 파라미터 =====
        self.rate_hz = rospy.get_param("~rate", 20)

        self.slam_cmd_topic = rospy.get_param("~slam_cmd_topic", "/cmd_vel_slam")
        self.out_cmd_topic  = rospy.get_param("~out_cmd_topic",  "/cmd_vel")

        self.depart_threshold = rospy.get_param("~depart_threshold", 0.25)
        self.clear_threshold  = rospy.get_param("~clear_threshold",  0.15)

        self.lane_gain = rospy.get_param("~lane_gain", 1.2)
        if rospy.has_param("~yaw_gain"):
            self.lane_gain = rospy.get_param("~yaw_gain")

        self.max_ang   = rospy.get_param("~max_ang",   0.9)
        self.deadzone  = rospy.get_param("~deadzone",  0.05)

        self.slam_timeout = rospy.get_param("~slam_timeout", 0.5)
        self.lane_timeout = rospy.get_param("~lane_timeout", 0.5)

        # ===== IMU / 방지턱 감속 파라미터 =====
        self.imu_timeout = rospy.get_param("~imu_timeout", 0.5)

        # Hysteresis 적용
        self.bump_on_deg  = rospy.get_param("~bump_on_deg", 12.0)
        self.bump_off_deg = rospy.get_param("~bump_off_deg", 5.0)

        # 감속 최대 속도
        self.bump_speed_max = rospy.get_param("~bump_speed_max", 0.06)

        # 최소 유지 시간
        self.bump_hold_time = rospy.get_param("~bump_hold_time", 1.0)

        # ===== 상태 변수 =====
        self.lock = threading.RLock()

        self.last_slam_cmd = Twist()
        self.last_slam_time = 0.0

        self.lane_offset = 0.0
        self.lane_valid = False
        self.last_lane_time = 0.0
        self.in_override = False

        self.f_ang = EWMA(alpha=0.6, init_val=0.0)

        # IMU pitch (Euler 기반)
        self.pitch_deg = 0.0
        self.last_imu_time = 0.0
        self.f_pitch = EWMA(alpha=0.85, init_val=0.0)

        # bump 상태
        self.bump_active = False
        self.bump_release_time = 0.0

        # ===== ROS I/O =====
        self.pub_cmd = rospy.Publisher(self.out_cmd_topic, Twist, queue_size=1)

        rospy.Subscriber(self.slam_cmd_topic, Twist, self.cb_slam)
        rospy.Subscriber("/lane_center_offset", Float32, self.cb_offset)
        rospy.Subscriber("/lane_center_valid",  Bool,    self.cb_valid)

        rospy.Subscriber("/imu", Imu, self.cb_imu)
        rospy.Subscriber("/imu/data", Imu, self.cb_imu)

        rospy.loginfo("[LKAS_GUARD] READY (Stable Euler IMU + Hysteresis + Smooth Clamp)")

        self.spin()

    # =================================
    # CALLBACKS
    # =================================
    def cb_slam(self, msg):
        with self.lock:
            self.last_slam_cmd = msg
            self.last_slam_time = rospy.get_time()

    def cb_offset(self, msg):
        with self.lock:
            self.lane_offset = msg.data
            self.last_lane_time = rospy.get_time()

    def cb_valid(self, msg):
        with self.lock:
            self.lane_valid = msg.data

    def cb_imu(self, msg):
        # orientation 기반 Euler pitch 계산 → accel 기반보다 극도로 안정적
        q = msg.orientation
        quat = [q.x, q.y, q.z, q.w]
        roll, pitch, yaw = euler_from_quaternion(quat)

        pitch_deg = pitch * 180.0 / math.pi
        pitch_deg = self.f_pitch.filt(pitch_deg)

        now = rospy.get_time()
        with self.lock:
            self.pitch_deg = pitch_deg
            self.last_imu_time = now

    # =================================
    # MAIN LOOP
    # =================================
    def spin(self):
        r = rospy.Rate(self.rate_hz)

        while not rospy.is_shutdown():
            now = rospy.get_time()

            with self.lock:
                slam = self.last_slam_cmd
                age_slam = now - self.last_slam_time

                offset = self.lane_offset
                lane_valid = self.lane_valid
                age_lane = now - self.last_lane_time

                pitch_deg = self.pitch_deg
                age_imu = now - self.last_imu_time

                bump_active = self.bump_active
                bump_release_time = self.bump_release_time

            cmd = Twist()

            # SLAM 명령 없으면 정지
            if age_slam > self.slam_timeout:
                with self.lock:
                    self.in_override = False
                self.pub_cmd.publish(cmd)
                r.sleep()
                continue

            # 기본 SLAM 명령 적용
            cmd = slam

            # ========== IMU bump 로직 ==========
            if age_imu <= self.imu_timeout:

                # 0.5초 간격 IMU 출력
                rospy.loginfo_throttle(0.5,
                    "[IMU] pitch=%.2f deg, bump=%s" %
                    (pitch_deg, str(bump_active))
                )

                # bump 상태머신(Hysteresis)
                if not bump_active:
                    if abs(pitch_deg) >= self.bump_on_deg:
                        bump_active = True
                        bump_release_time = now + self.bump_hold_time
                        rospy.loginfo("[LKAS_GUARD] BUMP ON (pitch=%.2f)" % abs(pitch_deg))

                else:
                    if now >= bump_release_time and abs(pitch_deg) <= self.bump_off_deg:
                        bump_active = False
                        rospy.loginfo("[LKAS_GUARD] BUMP OFF")

                # 상태 저장
                with self.lock:
                    self.bump_active = bump_active
                    self.bump_release_time = bump_release_time

                # 부드러운 감속 (soft clamp)
                if bump_active and cmd.linear.x != 0.0:
                    sign = 1.0 if cmd.linear.x > 0 else -1.0
                    target = sign * self.bump_speed_max
                    cmd.linear.x = 0.7 * cmd.linear.x + 0.3 * target

            # ========== LKAS 처리 ==========
            lane_ok = (age_lane <= self.lane_timeout) and lane_valid

            with self.lock:
                if lane_ok:
                    if abs(offset) >= self.depart_threshold:
                        self.in_override = True
                    elif abs(offset) <= self.clear_threshold:
                        self.in_override = False
                else:
                    self.in_override = False

                in_override = self.in_override

            # LKAS 제자리 회전
            if in_override and lane_ok:
                cmd.linear.x = 0.0

                ang = self.lane_gain * offset
                if abs(ang) < self.deadzone:
                    ang = 0.0

                ang = max(-self.max_ang, min(self.max_ang, ang))
                cmd.angular.z = self.f_ang.filt(ang)

                self.pub_cmd.publish(cmd)
                r.sleep()
                continue

            # 정상 주행 시 조향 필터
            cmd.angular.z = self.f_ang.filt(cmd.angular.z)

            self.pub_cmd.publish(cmd)
            r.sleep()


if __name__ == "__main__":
    try:
        LkasSlamGuard()
    except rospy.ROSInterruptException:
        pass
